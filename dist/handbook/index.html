<!DOCTYPE html>
<html lang="en">
<body>
    <link rel="stylesheet" href="../style/header.css">
    <header id="top-menu">
        <a id="home-page-logo">
            <svg fill="none" height="26" viewBox="0 0 27 26" width="27" xmlns="http://www.w3.org/2000/svg"><path clipRule="evenodd" d="m.98608 0h24.32332c.5446 0 .9861.436522.9861.975v24.05c0 .5385-.4415.975-.9861.975h-24.32332c-.544597 0-.98608-.4365-.98608-.975v-24.05c0-.538478.441483-.975.98608-.975zm13.63142 13.8324v-2.1324h-9.35841v2.1324h3.34111v9.4946h2.6598v-9.4946zm1.0604 9.2439c.4289.2162.9362.3784 1.5218.4865.5857.1081 1.2029.1622 1.8518.1622.6324 0 1.2331-.0595 1.8023-.1784.5691-.1189 1.0681-.3149 1.497-.5879s.7685-.6297 1.0187-1.0703.3753-.9852.3753-1.6339c0-.4703-.0715-.8824-.2145-1.2365-.1429-.3541-.3491-.669-.6186-.9447-.2694-.2757-.5925-.523-.9692-.7419s-.8014-.4257-1.2743-.6203c-.3465-.1406-.6572-.2771-.9321-.4095-.275-.1324-.5087-.2676-.7011-.4054-.1925-.1379-.3409-.2838-.4454-.4379-.1045-.154-.1567-.3284-.1567-.523 0-.1784.0467-.3392.1402-.4824.0935-.1433.2254-.2663.3959-.369s.3794-.1824.6269-.2392c.2474-.0567.5224-.0851.8248-.0851.22 0 .4523.0162.697.0486.2447.0325.4908.0825.7382.15.2475.0676.4881.1527.7218.2555.2337.1027.4495.2216.6475.3567v-2.4244c-.4015-.1514-.84-.2636-1.3157-.3365-.4756-.073-1.0214-.1095-1.6373-.1095-.6268 0-1.2207.0662-1.7816.1987-.5609.1324-1.0544.3392-1.4806.6203s-.763.6392-1.0104 1.0743c-.2475.4352-.3712.9555-.3712 1.5609 0 .7731.2268 1.4326.6805 1.9785.4537.546 1.1424 1.0082 2.0662 1.3866.363.146.7011.2892 1.0146.4298.3134.1405.5842.2865.8124.4378.2282.1514.4083.3162.5403.4946s.198.3811.198.6082c0 .1676-.0413.323-.1238.4662-.0825.1433-.2076.2676-.3753.373s-.3766.1879-.6268.2473c-.2502.0595-.5431.0892-.8785.0892-.5719 0-1.1383-.0986-1.6992-.2959-.5608-.1973-1.0805-.4933-1.5589-.8879z" fill="#fff" fillRule="evenodd" /></svg>
            <span>TypeScript</span>
        </a>
        <div class="navigation">
            <ul>
                <li><a href="../handbook">Handbook</a></li>
                <li><a href="../download">Download</a></li>
                <li><a href="../community">Community</a></li>
                <li><a href="./pages/playground">Playground</a></li>
                <li><a href="../tsconfigReference">TSConfig Reference</a></li>
            </ul>
        </div>
    </header>
    <main>
        
    </main>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style/style.css">
</head>
<body>
    <link rel="stylesheet" href="../style/handbookBase.css">
    <div id="doc-layout">
        <div id="sidebar">
            <table>
                <tr>
                    <td>
                        <div class="side-content">
                            <button type="button" class="collapsible">Get Started</button>
                            <div class="content">
                                <table>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('getStarted1');">TS for the New Programmer</button>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('getStarted2');">TS for JS Programmers</button>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('getStarted3');">TS for Functional Programmers</button>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="side-content">
                            <button type="button" class="collapsible">Handbook</button>
                            <div class="content">
                                <table>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('handbook1');">The TypeScript Handbook</button>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('handbook2');">The Basics</button>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('handbook3');">Everyday Types</button>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="side-content">
                            <button type="button" class="collapsible">Reference</button>
                            <div class="content">
                                <table>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('handbook1');">The TypeScript Handbook</button>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('handbook2');">The Basics</button>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <button type="button" onclick="displayDescription('handbook3');">Everyday Types</button>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </td>
                </tr>
                <script>
                    var coll = document.getElementsByClassName("collapsible");
                    var i;
                    for (i = 0; i < coll.length; i++) {
                      coll[i].addEventListener("click", function() {
                        this.classList.toggle("active");
                        var content = this.nextElementSibling;
                        if (content.style.display === "block") {
                          content.style.display = "none";
                        } else {
                          content.style.display = "block";
                        }
                      });
                    }

                    document.addEventListener('DOMContentLoaded', function() {
                    const sideContentDivs = document.querySelectorAll('.content');

                        sideContentDivs.forEach(div => {
                            div.addEventListener('click', function(event) {
                                if (event.target.tagName === 'BUTTON') {
                                    // Add 'selected-buttons' class to the parent div of the clicked button
                                    this.classList.add('selected-buttons');
                                }
                            });
                        });
                    });

                    function toggleDisplay() {
                        var content = document.querySelector('.content');
                        if (content.style.display === 'none') {
                            content.style.display = 'block';
                        } if (content.style.display === 'block') {
                            content.style.display = 'none';
                        }
                    }
                </script>
            </table>
        </div>
        <div id="description getStarted1" style="display: block; margin:auto; padding:0 2rem; max-width:1200px; min-width:0;">
            
            <h1>TypeScript for the New Programmer</h1>
<article>
<div id="section1">
<p>Congratulations on choosing TypeScript as one of your first languages — you're already making good decisions!</p>
<p>You've probably already heard that TypeScript is a &quot;flavor&quot; or &quot;variant&quot; of JavaScript.
The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.</p>
<h2>What is JavaScript? A Brief History</h2>
<p>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers.
At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual.
Due to this, early web browsers executed such code pretty slowly.
Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.</p>
<p>Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more.
On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code.
This is the long and gradual growth of &quot;the web&quot;, starting as a simple network of static pages, and evolving into a platform for rich <em>applications</em> of all kinds.</p>
<p>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js.
The &quot;run anywhere&quot; nature of JS makes it an attractive choice for cross-platform development.
There are many developers these days that use <em>only</em> JavaScript to program their entire stack!</p>
<p>To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines.
Every language has its own <em>quirks</em> — oddities and surprises, and JavaScript's humble beginning makes it have <em>many</em> of these. Some examples:</p>
<ul>
<li>
<p>JavaScript's equality operator (<code>==</code>) <em>coerces</em> its operands, leading to unexpected behavior:</p>
<pre><code class="language-shell">if (&quot;&quot; == 0) {
  // It is! But why??
}
if (1 &lt; x &lt; 3) {
  // True for *any* value of x!
}
</code></pre>
</li>
<li>
<p>JavaScript also allows accessing properties which aren't present:</p>
<pre><code class="language-js">const obj = { width: 10, height: 15 };
// Why is this NaN? Spelling is hard!
const area = obj.width * obj.heigth;
</code></pre>
</li>
</ul>
<p>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running.
When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.</p>
<h2>TypeScript: A Static Type Checker</h2>
<p>We said earlier that some languages wouldn't allow those buggy programs to run at all.
Detecting errors in code without running it is referred to as <em>static checking</em>.
Determining what's an error and what's not based on the kinds of values being operated on is known as static <em>type</em> checking.</p>
<p>TypeScript checks a program for errors before execution, and does so based on the <em>kinds of values</em>, making it a <em>static type checker</em>.
For example, the last example above has an error because of the <em>type</em> of <code>obj</code>.
Here's the error TypeScript found:</p>
<pre><code class="language-ts">// @errors: 2551
const obj = { width: 10, height: 15 };
const area = obj.width * obj.heigth;
</code></pre>
<h3>A Typed Superset of JavaScript</h3>
<p>How does TypeScript relate to JavaScript, though?</p>
<h4>Syntax</h4>
<p>TypeScript is a language that is a <em>superset</em> of JavaScript: JS syntax is therefore legal TS.
Syntax refers to the way we write text to form a program.
For example, this code has a <em>syntax</em> error because it's missing a <code>)</code>:</p>
<pre><code class="language-ts">// @errors: 1005
let a = (4
</code></pre>
<p>TypeScript doesn't consider any JavaScript code to be an error because of its syntax.
This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.</p>
<h4>Types</h4>
<p>However, TypeScript is a <em>typed</em> superset, meaning that it adds rules about how different kinds of values can be used.
The earlier error about <code>obj.heigth</code> was not a <em>syntax</em> error: it is an error of using some kind of value (a <em>type</em>) in an incorrect way.</p>
<p>As another example, this is JavaScript code that you can run in your browser, and it <em>will</em> log a value:</p>
<pre><code class="language-js">console.log(4 / []);
</code></pre>
<p>This syntactically-legal program logs <code>Infinity</code>.
TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:</p>
<pre><code class="language-ts">// @errors: 2363
console.log(4 / []);
</code></pre>
<p>It's possible you really <em>did</em> intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake.
TypeScript's type checker is designed to allow correct programs through while still catching as many common errors as possible.
(Later, we'll learn about settings you can use to configure how strictly TypeScript checks your code.)</p>
<p>If you move some code from a JavaScript file to a TypeScript file, you might see <em>type errors</em> depending on how the code is written.
These may be legitimate problems with the code, or TypeScript being overly conservative.
Throughout this guide we'll demonstrate how to add various TypeScript syntax to eliminate such errors.</p>
<h4>Runtime Behavior</h4>
<p>TypeScript is also a programming language that preserves the <em>runtime behavior</em> of JavaScript.
For example, dividing by zero in JavaScript produces <code>Infinity</code> instead of throwing a runtime exception.
As a principle, TypeScript <strong>never</strong> changes the runtime behavior of JavaScript code.</p>
<p>This means that if you move code from JavaScript to TypeScript, it is <strong>guaranteed</strong> to run the same way, even if TypeScript thinks that the code has type errors.</p>
<p>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.</p>
<!--
Missing subsection on the fact that TS extends JS to add syntax for type
specification.  (Since the immediately preceding text was raving about
how JS code can be used in TS.)
-->
<h4>Erased Types</h4>
<p>Roughly speaking, once TypeScript's compiler is done with checking your code, it <em>erases</em> the types to produce the resulting &quot;compiled&quot; code.
This means that once your code is compiled, the resulting plain JS code has no type information.</p>
<p>This also means that TypeScript never changes the <em>behavior</em> of your program based on the types it inferred.
The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.</p>
<p>Finally, TypeScript doesn't provide any additional runtime libraries.
Your programs will use the same standard library (or external libraries) as JavaScript programs, so there's no additional TypeScript-specific framework to learn.</p>
<!--
Should extend this paragraph to say that there's an exception of
allowing you to use newer JS features and transpile the code to an older
JS, and this might add small stubs of functionality when needed.  (Maybe
with an example --- something like `?.` would be good in showing readers
that this document is maintained.)
-->
<h2>Learning JavaScript and TypeScript</h2>
<p>We frequently see the question &quot;Should I learn JavaScript or TypeScript?&quot;.</p>
<p>The answer is that you can't learn TypeScript without learning JavaScript!
TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.</p>
<p>There are many, many resources available for programmers to learn JavaScript; you should <em>not</em> ignore these resources if you're writing TypeScript.
For example, there are about 20 times more StackOverflow questions tagged <code>javascript</code> than <code>typescript</code>, but <em>all</em> of the <code>javascript</code> questions also apply to TypeScript.</p>
<p>If you find yourself searching for something like &quot;how to sort a list in TypeScript&quot;, remember: <strong>TypeScript is JavaScript's runtime with a compile-time type checker</strong>.
The way you sort a list in TypeScript is the same way you do so in JavaScript.
If you find a resource that uses TypeScript directly, that's great too, but don't limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.</p>
<h2>Next Steps</h2>
<p>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:</p>
<ul>
<li>
<p>Learn some of the JavaScript fundamentals, we recommend either:</p>
<ul>
<li><a href="https://developer.microsoft.com/javascript/">Microsoft's JavaScript Resources</a> or</li>
<li><a href="https://developer.mozilla.org/docs/Web/JavaScript/Guide">JavaScript guide at the Mozilla Web Docs</a></li>
</ul>
</li>
<li>
<p>Continue to <a href="/docs/handbook/typescript-in-5-minutes.html">TypeScript for JavaScript Programmers</a></p>
</li>
<li>
<p>Read the full Handbook <a href="/docs/handbook/intro.html">from start to finish</a></p>
</li>
<li>
<p>Explore the <a href="/play#show-examples">Playground examples</a></p>
</li>
</ul>
<!-- Note: I'll be happy to write the following... -->
<!--
## Types

    * What's a type? (For newbies)
      * A type is a *kind* of value
      * Types implicitly define what operations make sense on them
      * Lots of different kinds, not just primitives
      * We can make descriptions for all kinds of values
      * The `any` type -- a quick description, what it is, and why it's bad
    * Inference 101
      * Examples
      * TypeScript can figure out types most of the time
      * Two places we'll ask you what the type is: Function boundaries, and later-initialized values
    * Co-learning JavaScript
      * You can+should read existing JS resources
      * Just paste it in and see what happens
      * Consider turning off 'strict' -->
</div>
<div id="section2">
  <h5>On this page</h5>
<p>[[toc]]</p>
</div>
</article>
        </div>
        <div id="description getStarted2" style="display: none; margin:auto; padding:0 2rem; max-width:1200px; min-width:0;">
            
            <h1>TypeScript for JavaScript Programmers</h1>
<article>
<div id="section1">
TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript's features, and an additional layer on top of these: TypeScript's type system.
<p>For example, JavaScript provides language primitives like <code>string</code> and <code>number</code>, but it doesn't check that you've consistently assigned these. TypeScript does.</p>
<p>This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.</p>
<p>This tutorial provides a brief overview of TypeScript, focusing on its type system.</p>
<h2>Types by Inference</h2>
<p>TypeScript knows the JavaScript language and will generate types for you in many cases.
For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.</p>
<pre><code class="language-ts">let helloWorld = &quot;Hello World&quot;;
//  ^?
</code></pre>
<p>By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That's how TypeScript knows that <code>helloWorld</code> is a <code>string</code> in the above example.</p>
<p>You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.</p>
<h2>Defining Types</h2>
<p>You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.</p>
<p>For example, to create an object with an inferred type which includes <code>name: string</code> and <code>id: number</code>, you can write:</p>
<pre><code class="language-js">const user = {
  name: &quot;Hayes&quot;, // [!code --]
  id: 0,// [!code ++]
};
</code></pre>
<p>You can explicitly describe this object's shape using an <code>interface</code> declaration:</p>
<pre><code class="language-ts">interface User {
  name: string;
  id: number;
}
</code></pre>
<p>You can then declare that a JavaScript object conforms to the shape of your new <code>interface</code> by using syntax like <code>: TypeName</code> after a variable declaration:</p>
<pre><code class="language-ts">interface User {
  name: string;
  id: number;
}
// ---cut---
const user: User = {
  name: &quot;Hayes&quot;,
  id: 0,
};
</code></pre>
<p>If you provide an object that doesn't match the interface you have provided, TypeScript will warn you:</p>
<pre><code class="language-ts">// @errors: 2322
interface User {
  name: string;
  id: number;
}

const user: User = {
  username: &quot;Hayes&quot;,  // [!code word:username]
  id: 0,
};
</code></pre>
<p>Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:</p>
<pre><code class="language-ts">interface User {
  name: string;
  id: number;
}

class UserAccount {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

const user: User = new UserAccount(&quot;Murphy&quot;, 1);
</code></pre>
<p>You can use interfaces to annotate parameters and return values to functions:</p>
<pre><code class="language-ts">// @noErrors
interface User {
  name: string;
  id: number;
}
// ---cut---
function deleteUser(user: User) {
  // ...
}

function getAdminUser(): User {
  //...
}
</code></pre>
<p>There is already a small set of primitive types available in JavaScript: <code>boolean</code>, <code>bigint</code>, <code>null</code>, <code>number</code>, <code>string</code>, <code>symbol</code>, and <code>undefined</code>, which you can use in an interface. TypeScript extends this list with a few more, such as <code>any</code> (allow anything), <a href="/play#example/unknown-and-never"><code>unknown</code></a> (ensure someone using this type declares what the type is), <a href="/play#example/unknown-and-never"><code>never</code></a> (it's not possible that this type could happen), and <code>void</code> (a function which returns <code>undefined</code> or has no return value).</p>
<p>You'll see that there are two syntaxes for building types: <a href="/play/?e=83#example/types-vs-interfaces">Interfaces and Types</a>. You should prefer <code>interface</code>. Use <code>type</code> when you need specific features.</p>
<h2>Composing Types</h2>
<p>With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.</p>
<h3>Unions</h3>
<p>With a union, you can declare that a type could be one of many types. For example, you can describe a <code>boolean</code> type as being either <code>true</code> or <code>false</code>:</p>
<pre><code class="language-ts">type MyBool = true | false;
</code></pre>
<p><em>Note:</em> If you hover over <code>MyBool</code> above, you'll see that it is classed as <code>boolean</code>. That's a property of the Structural Type System. More on this below.</p>
<p>A popular use-case for union types is to describe the set of <code>string</code> or <code>number</code> <a href="/docs/handbook/2/everyday-types.html#literal-types">literals</a> that a value is allowed to be:</p>
<pre><code class="language-ts">type WindowStates = &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;
type LockStates = &quot;locked&quot; | &quot;unlocked&quot;;
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
</code></pre>
<p>Unions provide a way to handle different types too. For example, you may have a function that takes an <code>array</code> or a <code>string</code>:</p>
<pre><code class="language-ts">function getLength(obj: string | string[]) {
  return obj.length;
}
</code></pre>
<p>To learn the type of a variable, use <code>typeof</code>:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Predicate</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td><code>typeof s === &quot;string&quot;</code></td>
</tr>
<tr>
<td>number</td>
<td><code>typeof n === &quot;number&quot;</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code>typeof b === &quot;boolean&quot;</code></td>
</tr>
<tr>
<td>undefined</td>
<td><code>typeof undefined === &quot;undefined&quot;</code></td>
</tr>
<tr>
<td>function</td>
<td><code>typeof f === &quot;function&quot;</code></td>
</tr>
<tr>
<td>array</td>
<td><code>Array.isArray(a)</code></td>
</tr>
</tbody>
</table>
<p>For example, you can make a function return different values depending on whether it is passed a string or an array:</p>
<!-- prettier-ignore -->
<pre><code class="language-ts">function wrapInArray(obj: string | string[]) {
  if (typeof obj === &quot;string&quot;) {
    return [obj];
//          ^?
  }
  return obj;
}
</code></pre>
<h3>Generics</h3>
<p>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.</p>
<pre><code class="language-ts">type StringArray = Array&lt;string&gt;;
type NumberArray = Array&lt;number&gt;;
type ObjectWithNameArray = Array&lt;{ name: string }&gt;;
</code></pre>
<p>You can declare your own types that use generics:</p>
<pre><code class="language-ts">// @errors: 2345
interface Backpack&lt;Type&gt; {
  add: (obj: Type) =&gt; void;
  get: () =&gt; Type;
}

// This line is a shortcut to tell TypeScript there is a
// constant called `backpack`, and to not worry about where it came from.
declare const backpack: Backpack&lt;string&gt;;

// object is a string, because we declared it above as the variable part of Backpack.
const object = backpack.get();

// Since the backpack variable is a string, you can't pass a number to the add function.
backpack.add(23);
</code></pre>
<h2>Structural Type System</h2>
<p>One of TypeScript's core principles is that type checking focuses on the <em>shape</em> that values have. This is sometimes called &quot;duck typing&quot; or &quot;structural typing&quot;.</p>
<p>In a structural type system, if two objects have the same shape, they are considered to be of the same type.</p>
<pre><code class="language-ts">interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}

// logs &quot;12, 26&quot;
const point = { x: 12, y: 26 };
logPoint(point);
</code></pre>
<p>The <code>point</code> variable is never declared to be a <code>Point</code> type. However, TypeScript compares the shape of <code>point</code> to the shape of <code>Point</code> in the type-check. They have the same shape, so the code passes.</p>
<p>The shape-matching only requires a subset of the object's fields to match.</p>
<pre><code class="language-ts">// @errors: 2345
interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}
// ---cut---
const point3 = { x: 12, y: 26, z: 89 };
logPoint(point3); // logs &quot;12, 26&quot;

const rect = { x: 33, y: 3, width: 30, height: 80 };
logPoint(rect); // logs &quot;33, 3&quot;

const color = { hex: &quot;#187ABF&quot; };
logPoint(color);
</code></pre>
<p>There is no difference between how classes and objects conform to shapes:</p>
<pre><code class="language-ts">// @errors: 2345
interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}
// ---cut---
class VirtualPoint {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const newVPoint = new VirtualPoint(13, 56);
logPoint(newVPoint); // logs &quot;13, 56&quot;
</code></pre>
<p>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.</p>
<h2>Next Steps</h2>
<p>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:</p>
<ul>
<li>Read the full Handbook <a href="/docs/handbook/intro.html">from start to finish</a></li>
<li>Explore the <a href="/play#show-examples">Playground examples</a></li>
</ul>
</div>
<div id="section2">
  <h5>On this page</h5>
<p>[[toc]]</p>
</div>
</article>

        </div>
        <div id="description getStarted3" style="display: none; margin:auto; padding:0 2rem; max-width:1200px; min-width:0;">
            
            <h1>TypeScript for Functional Programmers</h1>
<article>
<div id="section1">
TypeScript began its life as an attempt to bring traditional object-oriented types
to JavaScript so that the programmers at Microsoft could bring
traditional object-oriented programs to the web. As it has developed, TypeScript's type
system has evolved to model code written by native JavaScripters. The
resulting system is powerful, interesting and messy.
<p>This introduction is designed for working Haskell or ML programmers
who want to learn TypeScript. It describes how the type system of
TypeScript differs from Haskell's type system. It also describes
unique features of TypeScript's type system that arise from its
modelling of JavaScript code.</p>
<p>This introduction does not cover object-oriented programming. In
practice, object-oriented programs in TypeScript are similar to those
in other popular languages with OO features.</p>
<h2>Prerequisites</h2>
<p>In this introduction, I assume you know the following:</p>
<ul>
<li>How to program in JavaScript, the good parts.</li>
<li>Type syntax of a C-descended language.</li>
</ul>
<p>If you need to learn the good parts of JavaScript, read
<a href="https://shop.oreilly.com/product/9780596517748.do">JavaScript: The Good Parts</a>.
You may be able to skip the book if you know how to write programs in
a call-by-value lexically scoped language with lots of mutability and
not much else.
<a href="https://people.csail.mit.edu/jaffer/r4rs.pdf">R<sup>4</sup>RS Scheme</a> is a good example.</p>
<p><a href="http://www.stroustrup.com/4th.html">The C++ Programming Language</a> is
a good place to learn about C-style type syntax. Unlike C++,
TypeScript uses postfix types, like so: <code>x: string</code> instead of <code>string x</code>.</p>
<h2>Concepts not in Haskell</h2>
<h3>Built-in types</h3>
<p>JavaScript defines 8 built-in types:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Number</code></td>
<td>a double-precision IEEE 754 floating point.</td>
</tr>
<tr>
<td><code>String</code></td>
<td>an immutable UTF-16 string.</td>
</tr>
<tr>
<td><code>BigInt</code></td>
<td>integers in the arbitrary precision format.</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td><code>true</code> and <code>false</code>.</td>
</tr>
<tr>
<td><code>Symbol</code></td>
<td>a unique value usually used as a key.</td>
</tr>
<tr>
<td><code>Null</code></td>
<td>equivalent to the unit type.</td>
</tr>
<tr>
<td><code>Undefined</code></td>
<td>also equivalent to the unit type.</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>similar to records.</td>
</tr>
</tbody>
</table>
<p><a href="https://developer.mozilla.org/docs/Web/JavaScript/Data_structures">See the MDN page for more detail</a>.</p>
<p>TypeScript has corresponding primitive types for the built-in types:</p>
<ul>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>bigint</code></li>
<li><code>boolean</code></li>
<li><code>symbol</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>object</code></li>
</ul>
<h4>Other important TypeScript types</h4>
<table>
<thead>
<tr>
<th>Type</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unknown</code></td>
<td>the top type.</td>
</tr>
<tr>
<td><code>never</code></td>
<td>the bottom type.</td>
</tr>
<tr>
<td>object literal</td>
<td>eg <code>{ property: Type }</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td>for functions with no documented return value</td>
</tr>
<tr>
<td><code>T[]</code></td>
<td>mutable arrays, also written <code>Array&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>[T, T]</code></td>
<td>tuples, which are fixed-length but mutable</td>
</tr>
<tr>
<td><code>(t: T) =&gt; U</code></td>
<td>functions</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li>
<p>Function syntax includes parameter names. This is pretty hard to get used to!</p>
<pre><code class="language-ts">let fst: (a: any, b: any) =&gt; any = (a, b) =&gt; a;

// or more precisely:

let fst: &lt;T, U&gt;(a: T, b: U) =&gt; T = (a, b) =&gt; a;
</code></pre>
</li>
<li>
<p>Object literal type syntax closely mirrors object literal value syntax:</p>
<pre><code class="language-ts">let o: { n: number; xs: object[] } = { n: 1, xs: [] };
</code></pre>
</li>
<li>
<p><code>[T, T]</code> is a subtype of <code>T[]</code>. This is different than Haskell, where tuples are not related to lists.</p>
</li>
</ol>
<h4>Boxed types</h4>
<p>JavaScript has boxed equivalents of primitive types that contain the
methods that programmers associate with those types. TypeScript
reflects this with, for example, the difference between the primitive
type <code>number</code> and the boxed type <code>Number</code>. The boxed types are rarely
needed, since their methods return primitives.</p>
<pre><code class="language-ts">(1).toExponential();
// equivalent to
Number.prototype.toExponential.call(1);
</code></pre>
<p>Note that calling a method on a numeric literal requires it to be in
parentheses to aid the parser.</p>
<h3>Gradual typing</h3>
<p>TypeScript uses the type <code>any</code> whenever it can't tell what the type of
an expression should be. Compared to <code>Dynamic</code>, calling <code>any</code> a type
is an overstatement. It just turns off the type checker
wherever it appears. For example, you can push any value into an
<code>any[]</code> without marking the value in any way:</p>
<pre><code class="language-ts">// with &quot;noImplicitAny&quot;: false in tsconfig.json, anys: any[]
const anys = [];
anys.push(1);
anys.push(&quot;oh no&quot;);
anys.push({ anything: &quot;goes&quot; });
</code></pre>
<p>And you can use an expression of type <code>any</code> anywhere:</p>
<pre><code class="language-ts">anys.map(anys[1]); // oh no, &quot;oh no&quot; is not a function
</code></pre>
<p><code>any</code> is contagious, too — if you initialize a variable with an
expression of type <code>any</code>, the variable has type <code>any</code> too.</p>
<pre><code class="language-ts">let sepsis = anys[0] + anys[1]; // this could mean anything
</code></pre>
<p>To get an error when TypeScript produces an <code>any</code>, use
<code>&quot;noImplicitAny&quot;: true</code>, or <code>&quot;strict&quot;: true</code> in <code>tsconfig.json</code>.</p>
<h3>Structural typing</h3>
<p>Structural typing is a familiar concept to most functional
programmers, although Haskell and most MLs are not
structurally typed. Its basic form is pretty simple:</p>
<pre><code class="language-ts">// @strict: false
let o = { x: &quot;hi&quot;, extra: 1 }; // ok
let o2: { x: string } = o; // ok
</code></pre>
<p>Here, the object literal <code>{ x: &quot;hi&quot;, extra: 1 }</code> has a matching
literal type <code>{ x: string, extra: number }</code>. That
type is assignable to <code>{ x: string }</code> since
it has all the required properties and those properties have
assignable types. The extra property doesn't prevent assignment, it
just makes it a subtype of <code>{ x: string }</code>.</p>
<p>Named types just give a name to a type; for assignability purposes
there's no difference between the type alias <code>One</code> and the interface
type <code>Two</code> below. They both have a property <code>p: string</code>. (Type aliases
behave differently from interfaces with respect to recursive
definitions and type parameters, however.)</p>
<pre><code class="language-ts">// @errors: 2322
type One = { p: string };
interface Two {
  p: string;
}
class Three {
  p = &quot;Hello&quot;;
}

let x: One = { p: &quot;hi&quot; };
let two: Two = x;
two = new Three();
</code></pre>
<h3>Unions</h3>
<p>In TypeScript, union types are untagged. In other words, they are not
discriminated unions like <code>data</code> in Haskell. However, you can often
discriminate types in a union using built-in tags or other properties.</p>
<pre><code class="language-ts">function start(
  arg: string | string[] | (() =&gt; string) | { s: string }
): string {
  // this is super common in JavaScript
  if (typeof arg === &quot;string&quot;) {
    return commonCase(arg);
  } else if (Array.isArray(arg)) {
    return arg.map(commonCase).join(&quot;,&quot;);
  } else if (typeof arg === &quot;function&quot;) {
    return commonCase(arg());
  } else {
    return commonCase(arg.s);
  }

  function commonCase(s: string): string {
    // finally, just convert a string to another string
    return s;
  }
}
</code></pre>
<p><code>string</code>, <code>Array</code> and <code>Function</code> have built-in type predicates,
conveniently leaving the object type for the <code>else</code> branch. It is
possible, however, to generate unions that are difficult to
differentiate at runtime. For new code, it's best to build only
discriminated unions.</p>
<p>The following types have built-in predicates:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Predicate</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td><code>typeof s === &quot;string&quot;</code></td>
</tr>
<tr>
<td>number</td>
<td><code>typeof n === &quot;number&quot;</code></td>
</tr>
<tr>
<td>bigint</td>
<td><code>typeof m === &quot;bigint&quot;</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code>typeof b === &quot;boolean&quot;</code></td>
</tr>
<tr>
<td>symbol</td>
<td><code>typeof g === &quot;symbol&quot;</code></td>
</tr>
<tr>
<td>undefined</td>
<td><code>typeof undefined === &quot;undefined&quot;</code></td>
</tr>
<tr>
<td>function</td>
<td><code>typeof f === &quot;function&quot;</code></td>
</tr>
<tr>
<td>array</td>
<td><code>Array.isArray(a)</code></td>
</tr>
<tr>
<td>object</td>
<td><code>typeof o === &quot;object&quot;</code></td>
</tr>
</tbody>
</table>
<p>Note that functions and arrays are objects at runtime, but have their
own predicates.</p>
<h4>Intersections</h4>
<p>In addition to unions, TypeScript also has intersections:</p>
<pre><code class="language-ts">type Combined = { a: number } &amp; { b: string };
type Conflicting = { a: number } &amp; { a: string };
</code></pre>
<p><code>Combined</code> has two properties, <code>a</code> and <code>b</code>, just as if they had been
written as one object literal type. Intersection and union are
recursive in case of conflicts, so <code>Conflicting.a: number &amp; string</code>.</p>
<h3>Unit types</h3>
<p>Unit types are subtypes of primitive types that contain exactly one
primitive value. For example, the string <code>&quot;foo&quot;</code> has the type
<code>&quot;foo&quot;</code>. Since JavaScript has no built-in enums, it is common to use a set of
well-known strings instead. Unions of string literal types allow
TypeScript to type this pattern:</p>
<pre><code class="language-ts">declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;
pad(&quot;hi&quot;, 10, &quot;left&quot;);
</code></pre>
<p>When needed, the compiler <em>widens</em> — converts to a
supertype — the unit type to the primitive type, such as <code>&quot;foo&quot;</code>
to <code>string</code>. This happens when using mutability, which can hamper some
uses of mutable variables:</p>
<pre><code class="language-ts">// @errors: 2345
declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;
// ---cut---
let s = &quot;right&quot;;
pad(&quot;hi&quot;, 10, s); // error: 'string' is not assignable to '&quot;left&quot; | &quot;right&quot;'
</code></pre>
<p>Here's how the error happens:</p>
<ul>
<li><code>&quot;right&quot;: &quot;right&quot;</code></li>
<li><code>s: string</code> because <code>&quot;right&quot;</code> widens to <code>string</code> on assignment to a mutable variable.</li>
<li><code>string</code> is not assignable to <code>&quot;left&quot; | &quot;right&quot;</code></li>
</ul>
<p>You can work around this with a type annotation for <code>s</code>, but that
in turn prevents assignments to <code>s</code> of variables that are not of type
<code>&quot;left&quot; | &quot;right&quot;</code>.</p>
<pre><code class="language-ts">declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;
// ---cut---
let s: &quot;left&quot; | &quot;right&quot; = &quot;right&quot;;
pad(&quot;hi&quot;, 10, s);
</code></pre>
<h2>Concepts similar to Haskell</h2>
<h3>Contextual typing</h3>
<p>TypeScript has some obvious places where it can infer types, like
variable declarations:</p>
<pre><code class="language-ts">let s = &quot;I'm a string!&quot;;
</code></pre>
<p>But it also infers types in a few other places that you may not expect
if you've worked with other C-syntax languages:</p>
<pre><code class="language-ts">declare function map&lt;T, U&gt;(f: (t: T) =&gt; U, ts: T[]): U[];
let sns = map((n) =&gt; n.toString(), [1, 2, 3]);
</code></pre>
<p>Here, <code>n: number</code> in this example also, despite the fact that <code>T</code> and <code>U</code>
have not been inferred before the call. In fact, after <code>[1,2,3]</code> has
been used to infer <code>T=number</code>, the return type of <code>n =&gt; n.toString()</code>
is used to infer <code>U=string</code>, causing <code>sns</code> to have the type
<code>string[]</code>.</p>
<p>Note that inference will work in any order, but intellisense will only
work left-to-right, so TypeScript prefers to declare <code>map</code> with the
array first:</p>
<pre><code class="language-ts">declare function map&lt;T, U&gt;(ts: T[], f: (t: T) =&gt; U): U[];
</code></pre>
<p>Contextual typing also works recursively through object literals, and
on unit types that would otherwise be inferred as <code>string</code> or
<code>number</code>. And it can infer return types from context:</p>
<pre><code class="language-ts">declare function run&lt;T&gt;(thunk: (t: T) =&gt; void): T;
let i: { inference: string } = run((o) =&gt; {
  o.inference = &quot;INSERT STATE HERE&quot;;
});
</code></pre>
<p>The type of <code>o</code> is determined to be <code>{ inference: string }</code> because</p>
<ol>
<li>Declaration initializers are contextually typed by the
declaration's type: <code>{ inference: string }</code>.</li>
<li>The return type of a call uses the contextual type for inferences,
so the compiler infers that <code>T={ inference: string }</code>.</li>
<li>Arrow functions use the contextual type to type their parameters,
so the compiler gives <code>o: { inference: string }</code>.</li>
</ol>
<p>And it does so while you are typing, so that after typing <code>o.</code>, you
get completions for the property <code>inference</code>, along with any other
properties you'd have in a real program.
Altogether, this feature can make TypeScript's inference look a bit
like a unifying type inference engine, but it is not.</p>
<h3>Type aliases</h3>
<p>Type aliases are mere aliases, just like <code>type</code> in Haskell. The
compiler will attempt to use the alias name wherever it was used in
the source code, but does not always succeed.</p>
<pre><code class="language-ts">type Size = [number, number];
let x: Size = [101.1, 999.9];
</code></pre>
<p>The closest equivalent to <code>newtype</code> is a <em>tagged intersection</em>:</p>
<pre><code class="language-ts">type FString = string &amp; { __compileTimeOnly: any };
</code></pre>
<p>An <code>FString</code> is just like a normal string, except that the compiler
thinks it has a property named <code>__compileTimeOnly</code> that doesn't
actually exist. This means that <code>FString</code> can still be assigned to
<code>string</code>, but not the other way round.</p>
<h3>Discriminated Unions</h3>
<p>The closest equivalent to <code>data</code> is a union of types with discriminant
properties, normally called discriminated unions in TypeScript:</p>
<pre><code class="language-ts">type Shape =
  | { kind: &quot;circle&quot;; radius: number }
  | { kind: &quot;square&quot;; x: number }
  | { kind: &quot;triangle&quot;; x: number; y: number };
</code></pre>
<p>Unlike Haskell, the tag, or discriminant, is just a property in each
object type. Each variant has an identical property with a different
unit type. This is still a normal union type; the leading <code>|</code> is
an optional part of the union type syntax. You can discriminate the
members of the union using normal JavaScript code:</p>
<pre><code class="language-ts">type Shape =
  | { kind: &quot;circle&quot;; radius: number }
  | { kind: &quot;square&quot;; x: number }
  | { kind: &quot;triangle&quot;; x: number; y: number };

function area(s: Shape) {
  if (s.kind === &quot;circle&quot;) {
    return Math.PI * s.radius * s.radius;
  } else if (s.kind === &quot;square&quot;) {
    return s.x * s.x;
  } else {
    return (s.x * s.y) / 2;
  }
}
</code></pre>
<p>Note that the return type of <code>area</code> is inferred to be <code>number</code> because
TypeScript knows the function is total. If some variant is not
covered, the return type of <code>area</code> will be <code>number | undefined</code> instead.</p>
<p>Also, unlike Haskell, common properties show up in any union, so you
can usefully discriminate multiple members of the union:</p>
<pre><code class="language-ts">type Shape =
  | { kind: &quot;circle&quot;; radius: number }
  | { kind: &quot;square&quot;; x: number }
  | { kind: &quot;triangle&quot;; x: number; y: number };
// ---cut---
function height(s: Shape) {
  if (s.kind === &quot;circle&quot;) {
    return 2 * s.radius;
  } else {
    // s.kind: &quot;square&quot; | &quot;triangle&quot;
    return s.x;
  }
}
</code></pre>
<h3>Type Parameters</h3>
<p>Like most C-descended languages, TypeScript requires declaration of
type parameters:</p>
<pre><code class="language-ts">function liftArray&lt;T&gt;(t: T): Array&lt;T&gt; {
  return [t];
}
</code></pre>
<p>There is no case requirement, but type parameters are conventionally
single uppercase letters. Type parameters can also be constrained to a
type, which behaves a bit like type class constraints:</p>
<pre><code class="language-ts">function firstish&lt;T extends { length: number }&gt;(t1: T, t2: T): T {
  return t1.length &gt; t2.length ? t1 : t2;
}
</code></pre>
<p>TypeScript can usually infer type arguments from a call based on the
type of the arguments, so type arguments are usually not needed.</p>
<p>Because TypeScript is structural, it doesn't need type parameters as
much as nominal systems. Specifically, they are not needed to make a
function polymorphic. Type parameters should only be used to
<em>propagate</em> type information, such as constraining parameters to be
the same type:</p>
<pre><code class="language-ts">function length&lt;T extends ArrayLike&lt;unknown&gt;&gt;(t: T): number {}

function length(t: ArrayLike&lt;unknown&gt;): number {}
</code></pre>
<p>In the first <code>length</code>, T is not necessary; notice that it's only
referenced once, so it's not being used to constrain the type of the
return value or other parameters.</p>
<h4>Higher-kinded types</h4>
<p>TypeScript does not have higher kinded types, so the following is not legal:</p>
<pre><code class="language-ts">function length&lt;T extends ArrayLike&lt;unknown&gt;, U&gt;(m: T&lt;U&gt;) {}
</code></pre>
<h4>Point-free programming</h4>
<p>Point-free programming — heavy use of currying and function
composition — is possible in JavaScript, but can be verbose.
In TypeScript, type inference often fails for point-free programs, so
you'll end up specifying type parameters instead of value parameters. The
result is so verbose that it's usually better to avoid point-free
programming.</p>
<h3>Module system</h3>
<p>JavaScript's modern module syntax is a bit like Haskell's, except that
any file with <code>import</code> or <code>export</code> is implicitly a module:</p>
<pre><code class="language-ts">import { value, Type } from &quot;npm-package&quot;;
import { other, Types } from &quot;./local-package&quot;;
import * as prefix from &quot;../lib/third-package&quot;;
</code></pre>
<p>You can also import commonjs modules — modules written using node.js'
module system:</p>
<pre><code class="language-ts">import f = require(&quot;single-function-package&quot;);
</code></pre>
<p>You can export with an export list:</p>
<pre><code class="language-ts">export { f };

function f() {
  return g();
}
function g() {} // g is not exported
</code></pre>
<p>Or by marking each export individually:</p>
<pre><code class="language-ts">export function f() { return g() }
function g() { }
</code></pre>
<p>The latter style is more common but both are allowed, even in the same
file.</p>
<h3><code>readonly</code> and <code>const</code></h3>
<p>In JavaScript, mutability is the default, although it allows variable
declarations with <code>const</code> to declare that the <em>reference</em> is
immutable. The referent is still mutable:</p>
<pre><code class="language-js">const a = [1, 2, 3];
a.push(102); // ):
a[0] = 101; // D:
</code></pre>
<p>TypeScript additionally has a <code>readonly</code> modifier for properties.</p>
<pre><code class="language-ts">interface Rx {
  readonly x: number;
}
let rx: Rx = { x: 1 };
rx.x = 12; // error
</code></pre>
<p>It also ships with a mapped type <code>Readonly&lt;T&gt;</code> that makes
all properties <code>readonly</code>:</p>
<pre><code class="language-ts">interface X {
  x: number;
}
let rx: Readonly&lt;X&gt; = { x: 1 };
rx.x = 12; // error
</code></pre>
<p>And it has a specific <code>ReadonlyArray&lt;T&gt;</code> type that removes
side-affecting methods and prevents writing to indices of the array,
as well as special syntax for this type:</p>
<pre><code class="language-ts">let a: ReadonlyArray&lt;number&gt; = [1, 2, 3];
let b: readonly number[] = [1, 2, 3];
a.push(102); // error
b[0] = 101; // error
</code></pre>
<p>You can also use a const-assertion, which operates on arrays and
object literals:</p>
<pre><code class="language-ts">let a = [1, 2, 3] as const;
a.push(102); // error
a[0] = 101; // error
</code></pre>
<p>However, none of these options are the default, so they are not
consistently used in TypeScript code.</p>
<h3>Next Steps</h3>
<p>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:</p>
<ul>
<li>Read the full Handbook <a href="/docs/handbook/intro.html">from start to finish</a></li>
<li>Explore the <a href="/play#show-examples">Playground examples</a></li>
</ul>
</div>
<div id="section2">
  <h5>On this page</h5>
<p>[[toc]]</p>
</div>
</article>
        </div>
        <div id="description handbook1" style="display: none; margin:auto; padding:0 2rem; max-width:1200px; min-width:0;">
            
            <h1>The TypeScript Handbook</h1>
<article>
<div id="section1">
<h2>About this Handbook</h2>
<p>Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript's rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.</p>
<p>The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).</p>
<p>If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation on either the <a href="https://developer.microsoft.com/javascript/">Microsoft Learn JavaScript tutorial</a> or read <a href="https://developer.mozilla.org/docs/Web/JavaScript/Guide">JavaScript at the Mozilla Web Docs</a>.
If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.</p>
<h2>How is this Handbook Structured</h2>
<p>The handbook is split into two sections:</p>
<ul>
<li>
<p><strong>The Handbook</strong></p>
<p>The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.</p>
<p>You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language's features and behaviors.</p>
<p>A reader who completes the walkthrough should be able to:</p>
<ul>
<li>Read and understand commonly-used TypeScript syntax and patterns</li>
<li>Explain the effects of important compiler options</li>
<li>Correctly predict type system behavior in most cases</li>
</ul>
<p>In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.</p>
</li>
<li>
<p><strong>Reference Files</strong></p>
<p>The reference section below the handbook in the navigation is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.</p>
</li>
</ul>
<h3>Non-Goals</h3>
<p>The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won't be covered in order to keep things short.</p>
<p>Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we'll include links to background reading that you can use to read up on those concepts.</p>
<p>The Handbook also isn't intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript's behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven't read about yet.</p>
<p>Finally, the Handbook won't cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.</p>
<h2>Get Started</h2>
<p>Before getting started with <a href="/docs/handbook/2/basic-types.html">The Basics</a>, we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.</p>
<ul>
<li><a href="/docs/handbook/typescript-from-scratch.html">TypeScript for the New Programmer</a></li>
<li><a href="/docs/handbook/typescript-in-5-minutes.html">TypeScript for JavaScript Programmers</a></li>
<li><a href="/docs/handbook/typescript-in-5-minutes-oop.html">TypeScript for Java/C# Programmers</a></li>
<li><a href="/docs/handbook/typescript-in-5-minutes-func.html">TypeScript for Functional Programmers</a></li>
</ul>
<p>Otherwise, jump to <a href="/docs/handbook/2/basic-types.html">The Basics</a>.</p>
</div>
<div id="section2">
  <h5>On this page</h5>
<p>[[toc]]</p>
</div>
</article>
        </div>
        <div id="description handbook2" style="display: none; margin:auto; padding:0 2rem; max-width:1200px; min-width:0;">
            
            <h1>TypeScript for JavaScript Programmers</h1>
<article>
<div id="section1">
TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript's features, and an additional layer on top of these: TypeScript's type system.
<p>For example, JavaScript provides language primitives like <code>string</code> and <code>number</code>, but it doesn't check that you've consistently assigned these. TypeScript does.</p>
<p>This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.</p>
<p>This tutorial provides a brief overview of TypeScript, focusing on its type system.</p>
<h2>Types by Inference</h2>
<p>TypeScript knows the JavaScript language and will generate types for you in many cases.
For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.</p>
<pre><code class="language-ts">let helloWorld = &quot;Hello World&quot;;
//  ^?
</code></pre>
<p>By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That's how TypeScript knows that <code>helloWorld</code> is a <code>string</code> in the above example.</p>
<p>You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.</p>
<h2>Defining Types</h2>
<p>You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.</p>
<p>For example, to create an object with an inferred type which includes <code>name: string</code> and <code>id: number</code>, you can write:</p>
<pre><code class="language-js">const user = {
  name: &quot;Hayes&quot;, // [!code --]
  id: 0,// [!code ++]
};
</code></pre>
<p>You can explicitly describe this object's shape using an <code>interface</code> declaration:</p>
<pre><code class="language-ts">interface User {
  name: string;
  id: number;
}
</code></pre>
<p>You can then declare that a JavaScript object conforms to the shape of your new <code>interface</code> by using syntax like <code>: TypeName</code> after a variable declaration:</p>
<pre><code class="language-ts">interface User {
  name: string;
  id: number;
}
// ---cut---
const user: User = {
  name: &quot;Hayes&quot;,
  id: 0,
};
</code></pre>
<p>If you provide an object that doesn't match the interface you have provided, TypeScript will warn you:</p>
<pre><code class="language-ts">// @errors: 2322
interface User {
  name: string;
  id: number;
}

const user: User = {
  username: &quot;Hayes&quot;,  // [!code word:username]
  id: 0,
};
</code></pre>
<p>Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:</p>
<pre><code class="language-ts">interface User {
  name: string;
  id: number;
}

class UserAccount {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

const user: User = new UserAccount(&quot;Murphy&quot;, 1);
</code></pre>
<p>You can use interfaces to annotate parameters and return values to functions:</p>
<pre><code class="language-ts">// @noErrors
interface User {
  name: string;
  id: number;
}
// ---cut---
function deleteUser(user: User) {
  // ...
}

function getAdminUser(): User {
  //...
}
</code></pre>
<p>There is already a small set of primitive types available in JavaScript: <code>boolean</code>, <code>bigint</code>, <code>null</code>, <code>number</code>, <code>string</code>, <code>symbol</code>, and <code>undefined</code>, which you can use in an interface. TypeScript extends this list with a few more, such as <code>any</code> (allow anything), <a href="/play#example/unknown-and-never"><code>unknown</code></a> (ensure someone using this type declares what the type is), <a href="/play#example/unknown-and-never"><code>never</code></a> (it's not possible that this type could happen), and <code>void</code> (a function which returns <code>undefined</code> or has no return value).</p>
<p>You'll see that there are two syntaxes for building types: <a href="/play/?e=83#example/types-vs-interfaces">Interfaces and Types</a>. You should prefer <code>interface</code>. Use <code>type</code> when you need specific features.</p>
<h2>Composing Types</h2>
<p>With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.</p>
<h3>Unions</h3>
<p>With a union, you can declare that a type could be one of many types. For example, you can describe a <code>boolean</code> type as being either <code>true</code> or <code>false</code>:</p>
<pre><code class="language-ts">type MyBool = true | false;
</code></pre>
<p><em>Note:</em> If you hover over <code>MyBool</code> above, you'll see that it is classed as <code>boolean</code>. That's a property of the Structural Type System. More on this below.</p>
<p>A popular use-case for union types is to describe the set of <code>string</code> or <code>number</code> <a href="/docs/handbook/2/everyday-types.html#literal-types">literals</a> that a value is allowed to be:</p>
<pre><code class="language-ts">type WindowStates = &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;
type LockStates = &quot;locked&quot; | &quot;unlocked&quot;;
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
</code></pre>
<p>Unions provide a way to handle different types too. For example, you may have a function that takes an <code>array</code> or a <code>string</code>:</p>
<pre><code class="language-ts">function getLength(obj: string | string[]) {
  return obj.length;
}
</code></pre>
<p>To learn the type of a variable, use <code>typeof</code>:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Predicate</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td><code>typeof s === &quot;string&quot;</code></td>
</tr>
<tr>
<td>number</td>
<td><code>typeof n === &quot;number&quot;</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code>typeof b === &quot;boolean&quot;</code></td>
</tr>
<tr>
<td>undefined</td>
<td><code>typeof undefined === &quot;undefined&quot;</code></td>
</tr>
<tr>
<td>function</td>
<td><code>typeof f === &quot;function&quot;</code></td>
</tr>
<tr>
<td>array</td>
<td><code>Array.isArray(a)</code></td>
</tr>
</tbody>
</table>
<p>For example, you can make a function return different values depending on whether it is passed a string or an array:</p>
<!-- prettier-ignore -->
<pre><code class="language-ts">function wrapInArray(obj: string | string[]) {
  if (typeof obj === &quot;string&quot;) {
    return [obj];
//          ^?
  }
  return obj;
}
</code></pre>
<h3>Generics</h3>
<p>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.</p>
<pre><code class="language-ts">type StringArray = Array&lt;string&gt;;
type NumberArray = Array&lt;number&gt;;
type ObjectWithNameArray = Array&lt;{ name: string }&gt;;
</code></pre>
<p>You can declare your own types that use generics:</p>
<pre><code class="language-ts">// @errors: 2345
interface Backpack&lt;Type&gt; {
  add: (obj: Type) =&gt; void;
  get: () =&gt; Type;
}

// This line is a shortcut to tell TypeScript there is a
// constant called `backpack`, and to not worry about where it came from.
declare const backpack: Backpack&lt;string&gt;;

// object is a string, because we declared it above as the variable part of Backpack.
const object = backpack.get();

// Since the backpack variable is a string, you can't pass a number to the add function.
backpack.add(23);
</code></pre>
<h2>Structural Type System</h2>
<p>One of TypeScript's core principles is that type checking focuses on the <em>shape</em> that values have. This is sometimes called &quot;duck typing&quot; or &quot;structural typing&quot;.</p>
<p>In a structural type system, if two objects have the same shape, they are considered to be of the same type.</p>
<pre><code class="language-ts">interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}

// logs &quot;12, 26&quot;
const point = { x: 12, y: 26 };
logPoint(point);
</code></pre>
<p>The <code>point</code> variable is never declared to be a <code>Point</code> type. However, TypeScript compares the shape of <code>point</code> to the shape of <code>Point</code> in the type-check. They have the same shape, so the code passes.</p>
<p>The shape-matching only requires a subset of the object's fields to match.</p>
<pre><code class="language-ts">// @errors: 2345
interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}
// ---cut---
const point3 = { x: 12, y: 26, z: 89 };
logPoint(point3); // logs &quot;12, 26&quot;

const rect = { x: 33, y: 3, width: 30, height: 80 };
logPoint(rect); // logs &quot;33, 3&quot;

const color = { hex: &quot;#187ABF&quot; };
logPoint(color);
</code></pre>
<p>There is no difference between how classes and objects conform to shapes:</p>
<pre><code class="language-ts">// @errors: 2345
interface Point {
  x: number;
  y: number;
}

function logPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}
// ---cut---
class VirtualPoint {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const newVPoint = new VirtualPoint(13, 56);
logPoint(newVPoint); // logs &quot;13, 56&quot;
</code></pre>
<p>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.</p>
<h2>Next Steps</h2>
<p>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:</p>
<ul>
<li>Read the full Handbook <a href="/docs/handbook/intro.html">from start to finish</a></li>
<li>Explore the <a href="/play#show-examples">Playground examples</a></li>
</ul>
</div>
<div id="section2">
  <h5>On this page</h5>
<p>[[toc]]</p>
</div>
</article>

        </div>
        <div id="description handbook3" style="display: none; margin:auto; padding:0 2rem; max-width:1200px; min-width:0;">
            
            <h1>TypeScript for Functional Programmers</h1>
<article>
<div id="section1">
TypeScript began its life as an attempt to bring traditional object-oriented types
to JavaScript so that the programmers at Microsoft could bring
traditional object-oriented programs to the web. As it has developed, TypeScript's type
system has evolved to model code written by native JavaScripters. The
resulting system is powerful, interesting and messy.
<p>This introduction is designed for working Haskell or ML programmers
who want to learn TypeScript. It describes how the type system of
TypeScript differs from Haskell's type system. It also describes
unique features of TypeScript's type system that arise from its
modelling of JavaScript code.</p>
<p>This introduction does not cover object-oriented programming. In
practice, object-oriented programs in TypeScript are similar to those
in other popular languages with OO features.</p>
<h2>Prerequisites</h2>
<p>In this introduction, I assume you know the following:</p>
<ul>
<li>How to program in JavaScript, the good parts.</li>
<li>Type syntax of a C-descended language.</li>
</ul>
<p>If you need to learn the good parts of JavaScript, read
<a href="https://shop.oreilly.com/product/9780596517748.do">JavaScript: The Good Parts</a>.
You may be able to skip the book if you know how to write programs in
a call-by-value lexically scoped language with lots of mutability and
not much else.
<a href="https://people.csail.mit.edu/jaffer/r4rs.pdf">R<sup>4</sup>RS Scheme</a> is a good example.</p>
<p><a href="http://www.stroustrup.com/4th.html">The C++ Programming Language</a> is
a good place to learn about C-style type syntax. Unlike C++,
TypeScript uses postfix types, like so: <code>x: string</code> instead of <code>string x</code>.</p>
<h2>Concepts not in Haskell</h2>
<h3>Built-in types</h3>
<p>JavaScript defines 8 built-in types:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Number</code></td>
<td>a double-precision IEEE 754 floating point.</td>
</tr>
<tr>
<td><code>String</code></td>
<td>an immutable UTF-16 string.</td>
</tr>
<tr>
<td><code>BigInt</code></td>
<td>integers in the arbitrary precision format.</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td><code>true</code> and <code>false</code>.</td>
</tr>
<tr>
<td><code>Symbol</code></td>
<td>a unique value usually used as a key.</td>
</tr>
<tr>
<td><code>Null</code></td>
<td>equivalent to the unit type.</td>
</tr>
<tr>
<td><code>Undefined</code></td>
<td>also equivalent to the unit type.</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>similar to records.</td>
</tr>
</tbody>
</table>
<p><a href="https://developer.mozilla.org/docs/Web/JavaScript/Data_structures">See the MDN page for more detail</a>.</p>
<p>TypeScript has corresponding primitive types for the built-in types:</p>
<ul>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>bigint</code></li>
<li><code>boolean</code></li>
<li><code>symbol</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>object</code></li>
</ul>
<h4>Other important TypeScript types</h4>
<table>
<thead>
<tr>
<th>Type</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unknown</code></td>
<td>the top type.</td>
</tr>
<tr>
<td><code>never</code></td>
<td>the bottom type.</td>
</tr>
<tr>
<td>object literal</td>
<td>eg <code>{ property: Type }</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td>for functions with no documented return value</td>
</tr>
<tr>
<td><code>T[]</code></td>
<td>mutable arrays, also written <code>Array&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>[T, T]</code></td>
<td>tuples, which are fixed-length but mutable</td>
</tr>
<tr>
<td><code>(t: T) =&gt; U</code></td>
<td>functions</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li>
<p>Function syntax includes parameter names. This is pretty hard to get used to!</p>
<pre><code class="language-ts">let fst: (a: any, b: any) =&gt; any = (a, b) =&gt; a;

// or more precisely:

let fst: &lt;T, U&gt;(a: T, b: U) =&gt; T = (a, b) =&gt; a;
</code></pre>
</li>
<li>
<p>Object literal type syntax closely mirrors object literal value syntax:</p>
<pre><code class="language-ts">let o: { n: number; xs: object[] } = { n: 1, xs: [] };
</code></pre>
</li>
<li>
<p><code>[T, T]</code> is a subtype of <code>T[]</code>. This is different than Haskell, where tuples are not related to lists.</p>
</li>
</ol>
<h4>Boxed types</h4>
<p>JavaScript has boxed equivalents of primitive types that contain the
methods that programmers associate with those types. TypeScript
reflects this with, for example, the difference between the primitive
type <code>number</code> and the boxed type <code>Number</code>. The boxed types are rarely
needed, since their methods return primitives.</p>
<pre><code class="language-ts">(1).toExponential();
// equivalent to
Number.prototype.toExponential.call(1);
</code></pre>
<p>Note that calling a method on a numeric literal requires it to be in
parentheses to aid the parser.</p>
<h3>Gradual typing</h3>
<p>TypeScript uses the type <code>any</code> whenever it can't tell what the type of
an expression should be. Compared to <code>Dynamic</code>, calling <code>any</code> a type
is an overstatement. It just turns off the type checker
wherever it appears. For example, you can push any value into an
<code>any[]</code> without marking the value in any way:</p>
<pre><code class="language-ts">// with &quot;noImplicitAny&quot;: false in tsconfig.json, anys: any[]
const anys = [];
anys.push(1);
anys.push(&quot;oh no&quot;);
anys.push({ anything: &quot;goes&quot; });
</code></pre>
<p>And you can use an expression of type <code>any</code> anywhere:</p>
<pre><code class="language-ts">anys.map(anys[1]); // oh no, &quot;oh no&quot; is not a function
</code></pre>
<p><code>any</code> is contagious, too — if you initialize a variable with an
expression of type <code>any</code>, the variable has type <code>any</code> too.</p>
<pre><code class="language-ts">let sepsis = anys[0] + anys[1]; // this could mean anything
</code></pre>
<p>To get an error when TypeScript produces an <code>any</code>, use
<code>&quot;noImplicitAny&quot;: true</code>, or <code>&quot;strict&quot;: true</code> in <code>tsconfig.json</code>.</p>
<h3>Structural typing</h3>
<p>Structural typing is a familiar concept to most functional
programmers, although Haskell and most MLs are not
structurally typed. Its basic form is pretty simple:</p>
<pre><code class="language-ts">// @strict: false
let o = { x: &quot;hi&quot;, extra: 1 }; // ok
let o2: { x: string } = o; // ok
</code></pre>
<p>Here, the object literal <code>{ x: &quot;hi&quot;, extra: 1 }</code> has a matching
literal type <code>{ x: string, extra: number }</code>. That
type is assignable to <code>{ x: string }</code> since
it has all the required properties and those properties have
assignable types. The extra property doesn't prevent assignment, it
just makes it a subtype of <code>{ x: string }</code>.</p>
<p>Named types just give a name to a type; for assignability purposes
there's no difference between the type alias <code>One</code> and the interface
type <code>Two</code> below. They both have a property <code>p: string</code>. (Type aliases
behave differently from interfaces with respect to recursive
definitions and type parameters, however.)</p>
<pre><code class="language-ts">// @errors: 2322
type One = { p: string };
interface Two {
  p: string;
}
class Three {
  p = &quot;Hello&quot;;
}

let x: One = { p: &quot;hi&quot; };
let two: Two = x;
two = new Three();
</code></pre>
<h3>Unions</h3>
<p>In TypeScript, union types are untagged. In other words, they are not
discriminated unions like <code>data</code> in Haskell. However, you can often
discriminate types in a union using built-in tags or other properties.</p>
<pre><code class="language-ts">function start(
  arg: string | string[] | (() =&gt; string) | { s: string }
): string {
  // this is super common in JavaScript
  if (typeof arg === &quot;string&quot;) {
    return commonCase(arg);
  } else if (Array.isArray(arg)) {
    return arg.map(commonCase).join(&quot;,&quot;);
  } else if (typeof arg === &quot;function&quot;) {
    return commonCase(arg());
  } else {
    return commonCase(arg.s);
  }

  function commonCase(s: string): string {
    // finally, just convert a string to another string
    return s;
  }
}
</code></pre>
<p><code>string</code>, <code>Array</code> and <code>Function</code> have built-in type predicates,
conveniently leaving the object type for the <code>else</code> branch. It is
possible, however, to generate unions that are difficult to
differentiate at runtime. For new code, it's best to build only
discriminated unions.</p>
<p>The following types have built-in predicates:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Predicate</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td><code>typeof s === &quot;string&quot;</code></td>
</tr>
<tr>
<td>number</td>
<td><code>typeof n === &quot;number&quot;</code></td>
</tr>
<tr>
<td>bigint</td>
<td><code>typeof m === &quot;bigint&quot;</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code>typeof b === &quot;boolean&quot;</code></td>
</tr>
<tr>
<td>symbol</td>
<td><code>typeof g === &quot;symbol&quot;</code></td>
</tr>
<tr>
<td>undefined</td>
<td><code>typeof undefined === &quot;undefined&quot;</code></td>
</tr>
<tr>
<td>function</td>
<td><code>typeof f === &quot;function&quot;</code></td>
</tr>
<tr>
<td>array</td>
<td><code>Array.isArray(a)</code></td>
</tr>
<tr>
<td>object</td>
<td><code>typeof o === &quot;object&quot;</code></td>
</tr>
</tbody>
</table>
<p>Note that functions and arrays are objects at runtime, but have their
own predicates.</p>
<h4>Intersections</h4>
<p>In addition to unions, TypeScript also has intersections:</p>
<pre><code class="language-ts">type Combined = { a: number } &amp; { b: string };
type Conflicting = { a: number } &amp; { a: string };
</code></pre>
<p><code>Combined</code> has two properties, <code>a</code> and <code>b</code>, just as if they had been
written as one object literal type. Intersection and union are
recursive in case of conflicts, so <code>Conflicting.a: number &amp; string</code>.</p>
<h3>Unit types</h3>
<p>Unit types are subtypes of primitive types that contain exactly one
primitive value. For example, the string <code>&quot;foo&quot;</code> has the type
<code>&quot;foo&quot;</code>. Since JavaScript has no built-in enums, it is common to use a set of
well-known strings instead. Unions of string literal types allow
TypeScript to type this pattern:</p>
<pre><code class="language-ts">declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;
pad(&quot;hi&quot;, 10, &quot;left&quot;);
</code></pre>
<p>When needed, the compiler <em>widens</em> — converts to a
supertype — the unit type to the primitive type, such as <code>&quot;foo&quot;</code>
to <code>string</code>. This happens when using mutability, which can hamper some
uses of mutable variables:</p>
<pre><code class="language-ts">// @errors: 2345
declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;
// ---cut---
let s = &quot;right&quot;;
pad(&quot;hi&quot;, 10, s); // error: 'string' is not assignable to '&quot;left&quot; | &quot;right&quot;'
</code></pre>
<p>Here's how the error happens:</p>
<ul>
<li><code>&quot;right&quot;: &quot;right&quot;</code></li>
<li><code>s: string</code> because <code>&quot;right&quot;</code> widens to <code>string</code> on assignment to a mutable variable.</li>
<li><code>string</code> is not assignable to <code>&quot;left&quot; | &quot;right&quot;</code></li>
</ul>
<p>You can work around this with a type annotation for <code>s</code>, but that
in turn prevents assignments to <code>s</code> of variables that are not of type
<code>&quot;left&quot; | &quot;right&quot;</code>.</p>
<pre><code class="language-ts">declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;
// ---cut---
let s: &quot;left&quot; | &quot;right&quot; = &quot;right&quot;;
pad(&quot;hi&quot;, 10, s);
</code></pre>
<h2>Concepts similar to Haskell</h2>
<h3>Contextual typing</h3>
<p>TypeScript has some obvious places where it can infer types, like
variable declarations:</p>
<pre><code class="language-ts">let s = &quot;I'm a string!&quot;;
</code></pre>
<p>But it also infers types in a few other places that you may not expect
if you've worked with other C-syntax languages:</p>
<pre><code class="language-ts">declare function map&lt;T, U&gt;(f: (t: T) =&gt; U, ts: T[]): U[];
let sns = map((n) =&gt; n.toString(), [1, 2, 3]);
</code></pre>
<p>Here, <code>n: number</code> in this example also, despite the fact that <code>T</code> and <code>U</code>
have not been inferred before the call. In fact, after <code>[1,2,3]</code> has
been used to infer <code>T=number</code>, the return type of <code>n =&gt; n.toString()</code>
is used to infer <code>U=string</code>, causing <code>sns</code> to have the type
<code>string[]</code>.</p>
<p>Note that inference will work in any order, but intellisense will only
work left-to-right, so TypeScript prefers to declare <code>map</code> with the
array first:</p>
<pre><code class="language-ts">declare function map&lt;T, U&gt;(ts: T[], f: (t: T) =&gt; U): U[];
</code></pre>
<p>Contextual typing also works recursively through object literals, and
on unit types that would otherwise be inferred as <code>string</code> or
<code>number</code>. And it can infer return types from context:</p>
<pre><code class="language-ts">declare function run&lt;T&gt;(thunk: (t: T) =&gt; void): T;
let i: { inference: string } = run((o) =&gt; {
  o.inference = &quot;INSERT STATE HERE&quot;;
});
</code></pre>
<p>The type of <code>o</code> is determined to be <code>{ inference: string }</code> because</p>
<ol>
<li>Declaration initializers are contextually typed by the
declaration's type: <code>{ inference: string }</code>.</li>
<li>The return type of a call uses the contextual type for inferences,
so the compiler infers that <code>T={ inference: string }</code>.</li>
<li>Arrow functions use the contextual type to type their parameters,
so the compiler gives <code>o: { inference: string }</code>.</li>
</ol>
<p>And it does so while you are typing, so that after typing <code>o.</code>, you
get completions for the property <code>inference</code>, along with any other
properties you'd have in a real program.
Altogether, this feature can make TypeScript's inference look a bit
like a unifying type inference engine, but it is not.</p>
<h3>Type aliases</h3>
<p>Type aliases are mere aliases, just like <code>type</code> in Haskell. The
compiler will attempt to use the alias name wherever it was used in
the source code, but does not always succeed.</p>
<pre><code class="language-ts">type Size = [number, number];
let x: Size = [101.1, 999.9];
</code></pre>
<p>The closest equivalent to <code>newtype</code> is a <em>tagged intersection</em>:</p>
<pre><code class="language-ts">type FString = string &amp; { __compileTimeOnly: any };
</code></pre>
<p>An <code>FString</code> is just like a normal string, except that the compiler
thinks it has a property named <code>__compileTimeOnly</code> that doesn't
actually exist. This means that <code>FString</code> can still be assigned to
<code>string</code>, but not the other way round.</p>
<h3>Discriminated Unions</h3>
<p>The closest equivalent to <code>data</code> is a union of types with discriminant
properties, normally called discriminated unions in TypeScript:</p>
<pre><code class="language-ts">type Shape =
  | { kind: &quot;circle&quot;; radius: number }
  | { kind: &quot;square&quot;; x: number }
  | { kind: &quot;triangle&quot;; x: number; y: number };
</code></pre>
<p>Unlike Haskell, the tag, or discriminant, is just a property in each
object type. Each variant has an identical property with a different
unit type. This is still a normal union type; the leading <code>|</code> is
an optional part of the union type syntax. You can discriminate the
members of the union using normal JavaScript code:</p>
<pre><code class="language-ts">type Shape =
  | { kind: &quot;circle&quot;; radius: number }
  | { kind: &quot;square&quot;; x: number }
  | { kind: &quot;triangle&quot;; x: number; y: number };

function area(s: Shape) {
  if (s.kind === &quot;circle&quot;) {
    return Math.PI * s.radius * s.radius;
  } else if (s.kind === &quot;square&quot;) {
    return s.x * s.x;
  } else {
    return (s.x * s.y) / 2;
  }
}
</code></pre>
<p>Note that the return type of <code>area</code> is inferred to be <code>number</code> because
TypeScript knows the function is total. If some variant is not
covered, the return type of <code>area</code> will be <code>number | undefined</code> instead.</p>
<p>Also, unlike Haskell, common properties show up in any union, so you
can usefully discriminate multiple members of the union:</p>
<pre><code class="language-ts">type Shape =
  | { kind: &quot;circle&quot;; radius: number }
  | { kind: &quot;square&quot;; x: number }
  | { kind: &quot;triangle&quot;; x: number; y: number };
// ---cut---
function height(s: Shape) {
  if (s.kind === &quot;circle&quot;) {
    return 2 * s.radius;
  } else {
    // s.kind: &quot;square&quot; | &quot;triangle&quot;
    return s.x;
  }
}
</code></pre>
<h3>Type Parameters</h3>
<p>Like most C-descended languages, TypeScript requires declaration of
type parameters:</p>
<pre><code class="language-ts">function liftArray&lt;T&gt;(t: T): Array&lt;T&gt; {
  return [t];
}
</code></pre>
<p>There is no case requirement, but type parameters are conventionally
single uppercase letters. Type parameters can also be constrained to a
type, which behaves a bit like type class constraints:</p>
<pre><code class="language-ts">function firstish&lt;T extends { length: number }&gt;(t1: T, t2: T): T {
  return t1.length &gt; t2.length ? t1 : t2;
}
</code></pre>
<p>TypeScript can usually infer type arguments from a call based on the
type of the arguments, so type arguments are usually not needed.</p>
<p>Because TypeScript is structural, it doesn't need type parameters as
much as nominal systems. Specifically, they are not needed to make a
function polymorphic. Type parameters should only be used to
<em>propagate</em> type information, such as constraining parameters to be
the same type:</p>
<pre><code class="language-ts">function length&lt;T extends ArrayLike&lt;unknown&gt;&gt;(t: T): number {}

function length(t: ArrayLike&lt;unknown&gt;): number {}
</code></pre>
<p>In the first <code>length</code>, T is not necessary; notice that it's only
referenced once, so it's not being used to constrain the type of the
return value or other parameters.</p>
<h4>Higher-kinded types</h4>
<p>TypeScript does not have higher kinded types, so the following is not legal:</p>
<pre><code class="language-ts">function length&lt;T extends ArrayLike&lt;unknown&gt;, U&gt;(m: T&lt;U&gt;) {}
</code></pre>
<h4>Point-free programming</h4>
<p>Point-free programming — heavy use of currying and function
composition — is possible in JavaScript, but can be verbose.
In TypeScript, type inference often fails for point-free programs, so
you'll end up specifying type parameters instead of value parameters. The
result is so verbose that it's usually better to avoid point-free
programming.</p>
<h3>Module system</h3>
<p>JavaScript's modern module syntax is a bit like Haskell's, except that
any file with <code>import</code> or <code>export</code> is implicitly a module:</p>
<pre><code class="language-ts">import { value, Type } from &quot;npm-package&quot;;
import { other, Types } from &quot;./local-package&quot;;
import * as prefix from &quot;../lib/third-package&quot;;
</code></pre>
<p>You can also import commonjs modules — modules written using node.js'
module system:</p>
<pre><code class="language-ts">import f = require(&quot;single-function-package&quot;);
</code></pre>
<p>You can export with an export list:</p>
<pre><code class="language-ts">export { f };

function f() {
  return g();
}
function g() {} // g is not exported
</code></pre>
<p>Or by marking each export individually:</p>
<pre><code class="language-ts">export function f() { return g() }
function g() { }
</code></pre>
<p>The latter style is more common but both are allowed, even in the same
file.</p>
<h3><code>readonly</code> and <code>const</code></h3>
<p>In JavaScript, mutability is the default, although it allows variable
declarations with <code>const</code> to declare that the <em>reference</em> is
immutable. The referent is still mutable:</p>
<pre><code class="language-js">const a = [1, 2, 3];
a.push(102); // ):
a[0] = 101; // D:
</code></pre>
<p>TypeScript additionally has a <code>readonly</code> modifier for properties.</p>
<pre><code class="language-ts">interface Rx {
  readonly x: number;
}
let rx: Rx = { x: 1 };
rx.x = 12; // error
</code></pre>
<p>It also ships with a mapped type <code>Readonly&lt;T&gt;</code> that makes
all properties <code>readonly</code>:</p>
<pre><code class="language-ts">interface X {
  x: number;
}
let rx: Readonly&lt;X&gt; = { x: 1 };
rx.x = 12; // error
</code></pre>
<p>And it has a specific <code>ReadonlyArray&lt;T&gt;</code> type that removes
side-affecting methods and prevents writing to indices of the array,
as well as special syntax for this type:</p>
<pre><code class="language-ts">let a: ReadonlyArray&lt;number&gt; = [1, 2, 3];
let b: readonly number[] = [1, 2, 3];
a.push(102); // error
b[0] = 101; // error
</code></pre>
<p>You can also use a const-assertion, which operates on arrays and
object literals:</p>
<pre><code class="language-ts">let a = [1, 2, 3] as const;
a.push(102); // error
a[0] = 101; // error
</code></pre>
<p>However, none of these options are the default, so they are not
consistently used in TypeScript code.</p>
<h3>Next Steps</h3>
<p>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:</p>
<ul>
<li>Read the full Handbook <a href="/docs/handbook/intro.html">from start to finish</a></li>
<li>Explore the <a href="/play#show-examples">Playground examples</a></li>
</ul>
</div>
<div id="section2">
  <h5>On this page</h5>
<p>[[toc]]</p>
</div>
</article>
        </div>
        <script>
            var currentDiv = document.getElementById("description getStarted1");
            function displayDescription(parameter) {
                if (currentDiv) {
                    currentDiv.style.display = 'none';
                }
                var newDiv = document.getElementById("description" + " " + parameter);
                newDiv.style.display = 'block';
                currentDiv = newDiv;
            }
        </script>
    </div>
    <main>
        
    </main>
</body>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style/style.css">
</head>

<body>
    <link rel="stylesheet" href="../style/footer.css">
    <footer id="site-footer">
        <h3>Community</h3>
            <ul>
                <li><a href="./pages/handbook">Get Help</a></li>
                <li><a href="https://devblogs.microsoft.com/typescript/">Blog</a></li>
                <li>
                    <svg
                        fill="none"
                        height="12"
                        viewBox="0 0 12 12"
                        width="12"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                        <path
                          clipRule="evenodd"
                          d="m6.03927.165405c-3.27055 0-5.922909 2.652005-5.922909 5.923645 0 2.61709 1.697089 4.83705 4.050909 5.62035.29636.0546.40436-.1284.40436-.2854 0-.1408-.00509-.5131-.008-1.0073-1.64763.3578-1.99527-.7942-1.99527-.7942-.26946-.68436-.65782-.86654-.65782-.86654-.53782-.36727.04073-.36001.04073-.36001.59454.04182.90727.61055.90727.61055.52836.90509 1.38655.64364 1.724.492.05382-.38254.20691-.64363.376-.79163-1.31527-.14946-2.69818-.65782-2.69818-2.92764 0-.64654.23091-1.17564.60982-1.58946-.06109-.14981-.26437-.75236.05818-1.56763 0 0 .49709-.15927 1.62872.60727.47237-.13163.97928-.19709 1.48291-.19964.50328.00255 1.00982.06801 1.48291.19964 1.13091-.76654 1.62727-.60727 1.62727-.60727.32328.81527.12001 1.41782.05928 1.56763.37964.41382.60873.94292.60873 1.58946 0 2.27564-1.38509 2.77636-2.70437 2.92291.21237.18291.40182.54436.40182 1.09672 0 .79204-.00727 1.43094-.00727 1.62514 0 .1585.10691.3429.40727.2851 2.35197-.7851 4.04767-3.00369 4.04767-5.62005 0-3.27164-2.6524-5.923645-5.92403-5.923645z"
                          fill="#fffffe"
                          fillRule="evenodd"
                        />
                    </svg>
                    <a href="https://github.com/microsoft/TypeScript/#readme">GitHub Repo</a>
                </li>
                <li>
                    <svg
                      fill="none"
                      height="10"
                      viewBox="0 0 11 10"
                      width="11"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="m9.05511 0h-7.11021c-.59959 0-1.087753.46-1.087753 1.03v6.76c0 .57.488163 1.03 1.087753 1.03h6.01715l-.28123-.925.67918.595.64205.56 1.14085.95v-8.97c0-.57-.4882-1.03-1.08779-1.03zm-2.04817 6.53s-.19102-.215-.3502-.405c.6951-.185.96041-.595.96041-.595-.21755.135-.42449.23-.61021.295-.2653.105-.52.175-.76938.215-.50939.09-.97633.065-1.37429-.005-.30245-.055-.56245-.135-.78-.215-.12204-.045-.25469-.1-.38735-.17-.01592-.01-.03183-.015-.04775-.025-.01061-.005-.01592-.01-.02123-.015-.09551-.05-.14857-.085-.14857-.085s.2547.4.92857.59c-.15918.19-.35551.415-.35551.415-1.17265-.035-1.61836-.76-1.61836-.76 0-1.61.76408-2.915.76408-2.915.76408-.54 1.49102-.525 1.49102-.525l.05306.06c-.9551.26-1.39551.655-1.39551.655s.11673-.06.31306-.145c.56776-.235 1.01878-.3 1.20449-.315.03184-.005.05837-.01.0902-.01.32368-.04.6898-.05 1.07184-.01.50408.055 1.04531.195 1.59714.48 0 0-.41918-.375-1.32122-.635l.07428-.08s.72694-.015 1.49103.525c0 0 .76408 1.305.76408 2.915 0 0-.45102.725-1.62368.76z"
                        fill="#fff"
                      />
                    </svg>                    
                    <a href="https://discord.gg/typescript">Community Chat</a>
                </li>
                <li>
                    <svg
                        fill="none"
                        height="10"
                        viewBox="0 0 13 10"
                        width="13"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                        <path
                          d="m4.58519 10c4.62962 0 7.16291-3.83919 7.16291-7.16289 0-.10801 0-.21602-.0049-.32403.4909-.35348.918-.80024 1.2568-1.30591-.4517.20128-.9377.33384-1.4483.39766.5204-.30929.9181-.805148 1.1095-1.394284-.486.289658-1.026.495856-1.6004.608773-.4615-.490946-1.11448-.7953322-1.83617-.7953322-1.38938 0-2.51856 1.1291732-2.51856 2.5185532 0 .19638.02455.38785.06383.57441-2.09143-.1031-3.94721-1.10954-5.1893-2.631474-.21602.373119-.33876.805154-.33876 1.266644 0 .87388.44677 1.64467 1.11936 2.09634-.41239-.01473-.80024-.12765-1.13899-.31421v.03437c0 1.21754.86897 2.23871 2.01778 2.46946-.2111.05891-.43203.08837-.66277.08837-.16202 0-.31912-.01473-.47131-.04419.31911 1.00153 1.25191 1.72813 2.35163 1.74777-.86406.67751-1.94906 1.08008-3.12733 1.08008-.20128 0-.402571-.00982-.59895-.03436 1.10954.70696 2.43509 1.12425 3.85393 1.12425z"
                          fill="#fff"
                        />
                    </svg>
                    <a href="https://twitter.com/TypeScript">@TypeScript</a>
                </li>
                <li>
                    <svg
                        fill="none"
                        height="12"
                        viewBox="0 0 74 79"
                        width="12"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                        <path
                          d="M73.7014 17.4323C72.5616 9.05152 65.1774 2.4469 56.424 1.1671C54.9472 0.950843 49.3518 0.163818 36.3901 0.163818H36.2933C23.3281 0.163818 20.5465 0.950843 19.0697 1.1671C10.56 2.41145 2.78877 8.34604 0.903306 16.826C-0.00357854 21.0022 -0.100361 25.6322 0.068112 29.8793C0.308275 35.9699 0.354874 42.0498 0.91406 48.1156C1.30064 52.1448 1.97502 56.1419 2.93215 60.0769C4.72441 67.3445 11.9795 73.3925 19.0876 75.86C26.6979 78.4332 34.8821 78.8603 42.724 77.0937C43.5866 76.8952 44.4398 76.6647 45.2833 76.4024C47.1867 75.8033 49.4199 75.1332 51.0616 73.9562C51.0841 73.9397 51.1026 73.9184 51.1156 73.8938C51.1286 73.8693 51.1359 73.8421 51.1368 73.8144V67.9366C51.1364 67.9107 51.1302 67.8852 51.1186 67.862C51.1069 67.8388 51.0902 67.8184 51.0695 67.8025C51.0489 67.7865 51.0249 67.7753 50.9994 67.7696C50.9738 67.764 50.9473 67.7641 50.9218 67.7699C45.8976 68.9569 40.7491 69.5519 35.5836 69.5425C26.694 69.5425 24.3031 65.3699 23.6184 63.6327C23.0681 62.1314 22.7186 60.5654 22.5789 58.9744C22.5775 58.9477 22.5825 58.921 22.5934 58.8965C22.6043 58.8721 22.621 58.8505 22.6419 58.8336C22.6629 58.8167 22.6876 58.8049 22.714 58.7992C22.7404 58.7934 22.7678 58.794 22.794 58.8007C27.7345 59.9796 32.799 60.5746 37.8813 60.5733C39.1036 60.5733 40.3223 60.5733 41.5447 60.5414C46.6562 60.3996 52.0437 60.1408 57.0728 59.1694C57.1983 59.1446 57.3237 59.1233 57.4313 59.0914C65.3638 57.5847 72.9128 52.8555 73.6799 40.8799C73.7086 40.4084 73.7803 35.9415 73.7803 35.4523C73.7839 33.7896 74.3216 23.6576 73.7014 17.4323ZM61.4925 47.3144H53.1514V27.107C53.1514 22.8528 51.3591 20.6832 47.7136 20.6832C43.7061 20.6832 41.6988 23.2499 41.6988 28.3194V39.3803H33.4078V28.3194C33.4078 23.2499 31.3969 20.6832 27.3894 20.6832C23.7654 20.6832 21.9552 22.8528 21.9516 27.107V47.3144H13.6176V26.4937C13.6176 22.2395 14.7157 18.8598 16.9118 16.3545C19.1772 13.8552 22.1488 12.5719 25.8373 12.5719C30.1064 12.5719 33.3325 14.1955 35.4832 17.4394L37.5587 20.8853L39.6377 17.4394C41.7884 14.1955 45.0145 12.5719 49.2765 12.5719C52.9614 12.5719 55.9329 13.8552 58.2055 16.3545C60.4017 18.8574 61.4997 22.2371 61.4997 26.4937L61.4925 47.3144Z"
                          fill="#fff"
                        />
                    </svg>
                    <a href="https://fosstodon.org/@TypeScript">Mastodon</a>
                </li>
                <li>
                    <svg
                        fill="none"
                        height="16"
                        viewBox="0 0 12 16"
                        width="12"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="m.375 15.1875v-6h1.09375l-.03125 4.8125h7.1875v-4.78125h1.125v5.96875zm1.75-3.1563h5.625v1.1876h-5.625zm.03125-.9374.09375-1.2188 5.65625.5312-.125 1.2188zm.28125-2.4688.34375-1.1875 5.46875 1.53125-.34375 1.18745zm1.03125-2.90625.625-1.0625 4.84375 2.9375-.65625 1.0625zm2.40625-2.9375 1-.71875 3.3125 4.625-1 .71875zm3.625-1.78125 1.1875-.1875.9375 5.59375-1.2188.1875z"
                        fill="#fff"
                      />
                    </svg>
                    <a href="https://stackoverflow.com/questions/tagged/typescript">Stack Overflow</a>
                </li>
                <li>
                    <svg
                        fill="none"
                        height="12"
                        viewBox="0 0 12 12"
                        width="12"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                        <path
                          clipRule="evenodd"
                          d="m6.03927.165405c-3.27055 0-5.922909 2.652005-5.922909 5.923645 0 2.61709 1.697089 4.83705 4.050909 5.62035.29636.0546.40436-.1284.40436-.2854 0-.1408-.00509-.5131-.008-1.0073-1.64763.3578-1.99527-.7942-1.99527-.7942-.26946-.68436-.65782-.86654-.65782-.86654-.53782-.36727.04073-.36001.04073-.36001.59454.04182.90727.61055.90727.61055.52836.90509 1.38655.64364 1.724.492.05382-.38254.20691-.64363.376-.79163-1.31527-.14946-2.69818-.65782-2.69818-2.92764 0-.64654.23091-1.17564.60982-1.58946-.06109-.14981-.26437-.75236.05818-1.56763 0 0 .49709-.15927 1.62872.60727.47237-.13163.97928-.19709 1.48291-.19964.50328.00255 1.00982.06801 1.48291.19964 1.13091-.76654 1.62727-.60727 1.62727-.60727.32328.81527.12001 1.41782.05928 1.56763.37964.41382.60873.94292.60873 1.58946 0 2.27564-1.38509 2.77636-2.70437 2.92291.21237.18291.40182.54436.40182 1.09672 0 .79204-.00727 1.43094-.00727 1.62514 0 .1585.10691.3429.40727.2851 2.35197-.7851 4.04767-3.00369 4.04767-5.62005 0-3.27164-2.6524-5.923645-5.92403-5.923645z"
                          fill="#fffffe"
                          fillRule="evenodd"
                        />
                    </svg>
                    <a href="https://github.com/microsoft/TypeScript-Website">Web Repo</a>
                </li>
            </ul>
    </footer>
</body>
</html>

</html>